/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the GitHub repository.
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OpenCodePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  port: 14096,
  hostname: "127.0.0.1",
  autoStart: false,
  opencodePath: "opencode"
};
var OPENCODE_VIEW_TYPE = "opencode-view";

// src/OpenCodeView.ts
var import_obsidian = require("obsidian");
var OpenCodeView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.iframeEl = null;
    this.currentState = "stopped";
    this.plugin = plugin;
  }
  getViewType() {
    return OPENCODE_VIEW_TYPE;
  }
  getDisplayText() {
    return "OpenCode";
  }
  getIcon() {
    return "terminal";
  }
  async onOpen() {
    this.contentEl.empty();
    this.contentEl.addClass("opencode-container");
    this.plugin.onProcessStateChange((state) => {
      this.currentState = state;
      this.updateView();
    });
    this.currentState = this.plugin.getProcessState();
    this.updateView();
    if (this.currentState === "stopped") {
      this.plugin.startServer();
    }
  }
  async onClose() {
    if (this.iframeEl) {
      this.iframeEl.src = "about:blank";
      this.iframeEl = null;
    }
  }
  updateView() {
    switch (this.currentState) {
      case "stopped":
        this.renderStoppedState();
        break;
      case "starting":
        this.renderStartingState();
        break;
      case "running":
        this.renderRunningState();
        break;
      case "error":
        this.renderErrorState();
        break;
    }
  }
  renderStoppedState() {
    this.contentEl.empty();
    const statusContainer = this.contentEl.createDiv({
      cls: "opencode-status-container"
    });
    const iconEl = statusContainer.createDiv({ cls: "opencode-status-icon" });
    (0, import_obsidian.setIcon)(iconEl, "power-off");
    statusContainer.createEl("h3", { text: "OpenCode is stopped" });
    statusContainer.createEl("p", {
      text: "Click the button below to start the OpenCode server.",
      cls: "opencode-status-message"
    });
    const startButton = statusContainer.createEl("button", {
      text: "Start OpenCode",
      cls: "mod-cta"
    });
    startButton.addEventListener("click", () => {
      this.plugin.startServer();
    });
  }
  renderStartingState() {
    this.contentEl.empty();
    const statusContainer = this.contentEl.createDiv({
      cls: "opencode-status-container"
    });
    const loadingEl = statusContainer.createDiv({ cls: "opencode-loading" });
    loadingEl.createDiv({ cls: "opencode-spinner" });
    statusContainer.createEl("h3", { text: "Starting OpenCode..." });
    statusContainer.createEl("p", {
      text: "Please wait while the server starts up.",
      cls: "opencode-status-message"
    });
  }
  renderRunningState() {
    this.contentEl.empty();
    const headerEl = this.contentEl.createDiv({ cls: "opencode-header" });
    const titleSection = headerEl.createDiv({ cls: "opencode-header-title" });
    const iconEl = titleSection.createSpan();
    (0, import_obsidian.setIcon)(iconEl, "terminal");
    titleSection.createSpan({ text: "OpenCode" });
    const actionsEl = headerEl.createDiv({ cls: "opencode-header-actions" });
    const reloadButton = actionsEl.createEl("button", {
      attr: { "aria-label": "Reload" }
    });
    (0, import_obsidian.setIcon)(reloadButton, "refresh-cw");
    reloadButton.addEventListener("click", () => {
      this.reloadIframe();
    });
    const externalButton = actionsEl.createEl("button", {
      attr: { "aria-label": "Open in browser" }
    });
    (0, import_obsidian.setIcon)(externalButton, "external-link");
    externalButton.addEventListener("click", () => {
      window.open(this.plugin.getServerUrl(), "_blank");
    });
    const stopButton = actionsEl.createEl("button", {
      attr: { "aria-label": "Stop server" }
    });
    (0, import_obsidian.setIcon)(stopButton, "square");
    stopButton.addEventListener("click", () => {
      this.plugin.stopServer();
    });
    const iframeContainer = this.contentEl.createDiv({
      cls: "opencode-iframe-container"
    });
    this.iframeEl = iframeContainer.createEl("iframe", {
      cls: "opencode-iframe",
      attr: {
        src: this.plugin.getServerUrl(),
        frameborder: "0",
        allow: "clipboard-read; clipboard-write"
      }
    });
    this.iframeEl.addEventListener("error", () => {
      console.error("Failed to load OpenCode iframe");
    });
  }
  renderErrorState() {
    this.contentEl.empty();
    const statusContainer = this.contentEl.createDiv({
      cls: "opencode-status-container opencode-error"
    });
    const iconEl = statusContainer.createDiv({ cls: "opencode-status-icon" });
    (0, import_obsidian.setIcon)(iconEl, "alert-circle");
    statusContainer.createEl("h3", { text: "Failed to start OpenCode" });
    statusContainer.createEl("p", {
      text: "There was an error starting the OpenCode server. Please check that OpenCode is installed and try again.",
      cls: "opencode-status-message"
    });
    const retryButton = statusContainer.createEl("button", {
      text: "Retry",
      cls: "mod-cta"
    });
    retryButton.addEventListener("click", () => {
      this.plugin.startServer();
    });
    const settingsButton = statusContainer.createEl("button", {
      text: "Open Settings"
    });
    settingsButton.addEventListener("click", () => {
      this.app.setting.open();
      this.app.setting.openTabById("obsidian-opencode");
    });
  }
  reloadIframe() {
    if (this.iframeEl) {
      const src = this.iframeEl.src;
      this.iframeEl.src = "about:blank";
      setTimeout(() => {
        if (this.iframeEl) {
          this.iframeEl.src = src;
        }
      }, 100);
    }
  }
};

// src/SettingsTab.ts
var import_obsidian2 = require("obsidian");
var OpenCodeSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "OpenCode Settings" });
    containerEl.createEl("h3", { text: "Server Configuration" });
    new import_obsidian2.Setting(containerEl).setName("Port").setDesc("Port number for the OpenCode web server").addText(
      (text) => text.setPlaceholder("14096").setValue(this.plugin.settings.port.toString()).onChange(async (value) => {
        const port = parseInt(value, 10);
        if (!isNaN(port) && port > 0 && port < 65536) {
          this.plugin.settings.port = port;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Hostname").setDesc("Hostname to bind the server to (usually 127.0.0.1)").addText(
      (text) => text.setPlaceholder("127.0.0.1").setValue(this.plugin.settings.hostname).onChange(async (value) => {
        this.plugin.settings.hostname = value || "127.0.0.1";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("OpenCode path").setDesc(
      "Path to the OpenCode executable. Leave as 'opencode' if it's in your PATH."
    ).addText(
      (text) => text.setPlaceholder("opencode").setValue(this.plugin.settings.opencodePath).onChange(async (value) => {
        this.plugin.settings.opencodePath = value || "opencode";
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Behavior" });
    new import_obsidian2.Setting(containerEl).setName("Auto-start server").setDesc(
      "Automatically start the OpenCode server when Obsidian opens (not recommended for faster startup)"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoStart).onChange(async (value) => {
        this.plugin.settings.autoStart = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Server Status" });
    const statusContainer = containerEl.createDiv({ cls: "opencode-settings-status" });
    this.renderServerStatus(statusContainer);
  }
  renderServerStatus(container) {
    container.empty();
    const state = this.plugin.getProcessState();
    const statusText = {
      stopped: "Stopped",
      starting: "Starting...",
      running: "Running",
      error: "Error"
    };
    const statusClass = {
      stopped: "status-stopped",
      starting: "status-starting",
      running: "status-running",
      error: "status-error"
    };
    const statusEl = container.createDiv({ cls: "opencode-status-line" });
    statusEl.createSpan({ text: "Status: " });
    statusEl.createSpan({
      text: statusText[state],
      cls: `opencode-status-badge ${statusClass[state]}`
    });
    if (state === "running") {
      const urlEl = container.createDiv({ cls: "opencode-status-line" });
      urlEl.createSpan({ text: "URL: " });
      const linkEl = urlEl.createEl("a", {
        text: this.plugin.getServerUrl(),
        href: this.plugin.getServerUrl()
      });
      linkEl.addEventListener("click", (e) => {
        e.preventDefault();
        window.open(this.plugin.getServerUrl(), "_blank");
      });
    }
    const buttonContainer = container.createDiv({ cls: "opencode-settings-buttons" });
    if (state === "stopped" || state === "error") {
      const startButton = buttonContainer.createEl("button", {
        text: "Start Server",
        cls: "mod-cta"
      });
      startButton.addEventListener("click", async () => {
        await this.plugin.startServer();
        this.renderServerStatus(container);
      });
    }
    if (state === "running") {
      const stopButton = buttonContainer.createEl("button", {
        text: "Stop Server"
      });
      stopButton.addEventListener("click", () => {
        this.plugin.stopServer();
        this.renderServerStatus(container);
      });
      const restartButton = buttonContainer.createEl("button", {
        text: "Restart Server",
        cls: "mod-warning"
      });
      restartButton.addEventListener("click", async () => {
        this.plugin.stopServer();
        await this.plugin.startServer();
        this.renderServerStatus(container);
      });
    }
    if (state === "starting") {
      buttonContainer.createSpan({
        text: "Please wait...",
        cls: "opencode-status-waiting"
      });
    }
  }
};

// src/ProcessManager.ts
var import_child_process = require("child_process");
var import_obsidian3 = require("obsidian");
var ProcessManager = class {
  constructor(settings, workingDirectory, projectDirectory, onStateChange) {
    this.process = null;
    this.state = "stopped";
    this.startupTimeout = null;
    this.settings = settings;
    this.workingDirectory = workingDirectory;
    this.projectDirectory = projectDirectory;
    this.onStateChange = onStateChange;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getState() {
    return this.state;
  }
  getUrl() {
    return `http://${this.settings.hostname}:${this.settings.port}`;
  }
  async start() {
    var _a, _b;
    if (this.state === "running" || this.state === "starting") {
      return true;
    }
    this.setState("starting");
    try {
      const alreadyRunning = await this.checkServerHealth();
      if (alreadyRunning) {
        console.log("OpenCode server already running on port", this.settings.port);
        this.setState("running");
        return true;
      }
      console.log("[OpenCode] Starting server:", {
        path: this.settings.opencodePath,
        cwd: this.workingDirectory,
        project: this.projectDirectory,
        port: this.settings.port,
        hostname: this.settings.hostname
      });
      this.process = (0, import_child_process.spawn)(
        this.settings.opencodePath,
        [
          "serve",
          this.projectDirectory,
          "--port",
          this.settings.port.toString(),
          "--hostname",
          this.settings.hostname,
          "--cors",
          "app://obsidian.md"
        ],
        {
          cwd: this.workingDirectory,
          env: { ...process.env },
          stdio: ["ignore", "pipe", "pipe"],
          detached: false
        }
      );
      console.log("[OpenCode] Process spawned with PID:", this.process.pid);
      (_a = this.process.stdout) == null ? void 0 : _a.on("data", (data) => {
        console.log("[OpenCode]", data.toString().trim());
      });
      (_b = this.process.stderr) == null ? void 0 : _b.on("data", (data) => {
        console.error("[OpenCode Error]", data.toString().trim());
      });
      this.process.on("exit", (code, signal) => {
        console.log(`OpenCode process exited with code ${code}, signal ${signal}`);
        this.process = null;
        if (this.state === "running") {
          this.setState("stopped");
        }
      });
      this.process.on("error", (err) => {
        console.error("Failed to start OpenCode process:", err);
        new import_obsidian3.Notice(`Failed to start OpenCode: ${err.message}`);
        this.process = null;
        this.setState("error");
      });
      const ready = await this.waitForServerOrExit(15e3);
      if (ready) {
        this.setState("running");
        return true;
      } else {
        this.stop();
        this.setState("error");
        new import_obsidian3.Notice("OpenCode server failed to start within timeout");
        return false;
      }
    } catch (error) {
      console.error("Error starting OpenCode:", error);
      this.setState("error");
      return false;
    }
  }
  stop() {
    if (this.startupTimeout) {
      clearTimeout(this.startupTimeout);
      this.startupTimeout = null;
    }
    if (this.process) {
      try {
        this.process.kill("SIGTERM");
        setTimeout(() => {
          if (this.process && !this.process.killed) {
            this.process.kill("SIGKILL");
          }
        }, 2e3);
      } catch (error) {
        console.error("Error stopping OpenCode process:", error);
      }
      this.process = null;
    }
    this.setState("stopped");
  }
  setState(state) {
    this.state = state;
    this.onStateChange(state);
  }
  async checkServerHealth() {
    try {
      const response = await fetch(`${this.getUrl()}/global/health`, {
        method: "GET",
        signal: AbortSignal.timeout(2e3)
      });
      return response.ok;
    } catch (e) {
      return false;
    }
  }
  async waitForServerOrExit(timeoutMs) {
    const startTime = Date.now();
    const pollInterval = 500;
    while (Date.now() - startTime < timeoutMs) {
      if (!this.process) {
        console.log("OpenCode process exited before server became ready");
        return false;
      }
      if (await this.checkServerHealth()) {
        return true;
      }
      await this.sleep(pollInterval);
    }
    return false;
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};

// src/main.ts
var OpenCodePlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.processManager = null;
    this.stateChangeCallbacks = [];
  }
  async onload() {
    console.log("Loading OpenCode plugin");
    await this.loadSettings();
    this.processManager = new ProcessManager(
      this.settings,
      this.getVaultPath(),
      this.getVaultPath(),
      (state) => this.notifyStateChange(state)
    );
    this.registerView(OPENCODE_VIEW_TYPE, (leaf) => new OpenCodeView(leaf, this));
    this.addRibbonIcon("terminal", "OpenCode", () => {
      this.activateView();
    });
    this.addCommand({
      id: "toggle-opencode-view",
      name: "Toggle OpenCode panel",
      callback: () => {
        this.toggleView();
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "o"
        }
      ]
    });
    this.addCommand({
      id: "start-opencode-server",
      name: "Start OpenCode server",
      callback: () => {
        this.startServer();
      }
    });
    this.addCommand({
      id: "stop-opencode-server",
      name: "Stop OpenCode server",
      callback: () => {
        this.stopServer();
      }
    });
    this.addSettingTab(new OpenCodeSettingTab(this.app, this));
    if (this.settings.autoStart) {
      this.app.workspace.onLayoutReady(async () => {
        await this.startServer();
      });
    }
    console.log("OpenCode plugin loaded");
  }
  async onunload() {
    console.log("Unloading OpenCode plugin");
    this.stopServer();
    this.app.workspace.detachLeavesOfType(OPENCODE_VIEW_TYPE);
    console.log("OpenCode plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.processManager) {
      this.processManager.updateSettings(this.settings);
    }
  }
  // Get existing view leaf if any
  getExistingLeaf() {
    const leaves = this.app.workspace.getLeavesOfType(OPENCODE_VIEW_TYPE);
    return leaves.length > 0 ? leaves[0] : null;
  }
  // Activate or create the view
  async activateView() {
    const existingLeaf = this.getExistingLeaf();
    if (existingLeaf) {
      this.app.workspace.revealLeaf(existingLeaf);
      return;
    }
    const leaf = this.app.workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: OPENCODE_VIEW_TYPE,
        active: true
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
  // Toggle view visibility
  async toggleView() {
    const existingLeaf = this.getExistingLeaf();
    if (existingLeaf) {
      const rightSplit = this.app.workspace.rightSplit;
      if (rightSplit && !rightSplit.collapsed) {
        existingLeaf.detach();
      } else {
        this.app.workspace.revealLeaf(existingLeaf);
      }
    } else {
      await this.activateView();
    }
  }
  // Start the OpenCode server
  async startServer() {
    if (!this.processManager) {
      new import_obsidian4.Notice("OpenCode: Process manager not initialized");
      return false;
    }
    const success = await this.processManager.start();
    if (success) {
      new import_obsidian4.Notice("OpenCode server started");
    }
    return success;
  }
  // Stop the OpenCode server
  stopServer() {
    if (this.processManager) {
      this.processManager.stop();
      new import_obsidian4.Notice("OpenCode server stopped");
    }
  }
  // Get the current process state
  getProcessState() {
    var _a, _b;
    return (_b = (_a = this.processManager) == null ? void 0 : _a.getState()) != null ? _b : "stopped";
  }
  // Get the server URL
  getServerUrl() {
    var _a, _b;
    return (_b = (_a = this.processManager) == null ? void 0 : _a.getUrl()) != null ? _b : `http://127.0.0.1:${this.settings.port}`;
  }
  // Subscribe to process state changes
  onProcessStateChange(callback) {
    this.stateChangeCallbacks.push(callback);
  }
  // Notify all subscribers of state change
  notifyStateChange(state) {
    for (const callback of this.stateChangeCallbacks) {
      callback(state);
    }
  }
  // Get the vault path
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    return adapter.basePath || "";
  }
};
